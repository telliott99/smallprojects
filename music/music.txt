Some peculiarities of the file 'Purchased.txt'

- leading ff fe
- data is UTF-16
- use of '\r' for newlines

Seeing ff fe as the (incorrect) byte order mark (BOM) indicates that the data is little-endian, with the least significant byte first.  Hence, the next bytes are 4e 00 61 00 6d 00 65, or 'Name' in little-endian UTF-8 format.

A third peculiarity is the use of '\r' (hex '\x0d') alone for newline as seen in this part of the hexdump:

00000250  69 00 6f 00 6e 00 0d 00  4c 00 65 00 61 00 74 00  |i.o.n...L.e.a.t.|

This is a dinosaur from pre-OS X days in the mid-1990s.

Python loads the data as single bytes.  If we split the data on the correct newline and print a single entry, we get text.  But if we print a slice like

print L[:2]

we get

['\x00L\x00e\x00a\x00t\x00h\x00e\x00r\x00 \x00a\x00n\x00d\x00 \x00L\x00a\x00c\x00e\x00 \x00(\x00R\x00e\x00m\x00a\x00s\x0 ...

Interim solution:

- read the data from the file as bytes
- remove the first two bytes
- remove the even numbered bytes
- split on '\r'

Then, to deal with each entry.  There are a lot of fields, luckily the path is the last one.  Additionally, the path is weird, because the filename components contain spaces (which is no big deal), but the path separator is ':' and there is a leading 'Macintosh HD'.  Finally cleaned up, we print the result.  Running the script, we save the paths in a text file.